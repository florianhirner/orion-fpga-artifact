# data = [
#     0x1110, 0x1312, 0x1514, 0x1716, 0x1918, 0x1b1a, 0x1d1c, 0x1f1e,
#     0x2120, 0x2322, 0x2524, 0x2726, 0x2928, 0x2b2a, 0x2d2c, 0x2f2e,
#     0x3130, 0x3332, 0x3534, 0x3736, 0x3938, 0x3b3a, 0x3d3c, 0x3f3e,
#     0x4140, 0x4342, 0x4544, 0x4746, 0x4948, 0x4b4a, 0x4d4c, 0x4f4e,
#     0x5150, 0x5352, 0x5554, 0x5756, 0x5958, 0x5b5a, 0x5d5c, 0x5f5e
# ]

# with open("output.bin", "wb") as f:
#     for word in data:
#         f.write(word.to_bytes(2, byteorder='big'))  # Big-endian format


data = [
    0x0000000000000001_0000000000000000,
    0x0000000000000003_0000000000000002,
    0x0000000000000005_0000000000000004,
    0x0000000000000007_0000000000000006,
    0x0000000000000009_0000000000000008,
    0x000000000000000b_000000000000000a,
    0x000000000000000d_000000000000000c,
    0x000000000000000f_000000000000000e
]

with open("output.bin", "wb") as f:
    for word in data:
        f.write(word.to_bytes(16, byteorder='big'))  # Big-endian format
        # f.write(word.to_bytes(16, byteorder='little'))  # Big-endian format
        # f.write(word.to_bytes(16))


###########
###########
###########
###########
###########
###########
###########

val = 0x0033_0032_0031_0030_0023_0022_0021_0020

# Save as little-endian 128-bit (16 bytes)
with open("val_le.bin", "wb") as f:
    f.write(val.to_bytes(16, byteorder='little'))


with open("val_le.bin", "rb") as f:
    data = f.read()

# Interpret as little-endian integer (reverse byte order if needed)
val = int.from_bytes(data, byteorder='little')

# Print like: 0x00000000000000030000000000000002
print(f"0x{val:0{len(data)*2}x}")


###########
###########
###########
###########
###########
###########
###########

data512 = [
    0x0083008200810080_0073007200710070_0063006200610060_0053005200510050_0043004200410040_0033003200310030_0023002200210020_0013001200110010,
    0x0083008200811080_0073007200711070_0063006200611060_0053005200511050_0043004200411040_0033003200311030_0023002200211020_0013001200111010,
    0x0083008200812080_0073007200712070_0063006200612060_0053005200512050_0043004200412040_0033003200312030_0023002200212020_0013001200112010,
    0x0083008200813080_0073007200713070_0063006200613060_0053005200513050_0043004200413040_0033003200313030_0023002200213020_0013001200113010,
    0x0083008200814080_0073007200714070_0063006200614060_0053005200514050_0043004200414040_0033003200314030_0023002200214020_0013001200114010,
    0x0083008200815080_0073007200715070_0063006200615060_0053005200515050_0043004200415040_0033003200315030_0023002200215020_0013001200115010,
    0x0083008200816080_0073007200716070_0063006200616060_0053005200516050_0043004200416040_0033003200316030_0023002200216020_0013001200116010,
    0x0083008200817080_0073007200717070_0063006200617060_0053005200517050_0043004200417040_0033003200317030_0023002200217020_0013001200117010
]

#val = 0x0083008200810080_0073007200710070_0063006200610060_0053005200510050_0043004200410040_0033003200310030_0023002200210020_0013001200110010

# Save as little-endian 512-bit (64 bytes)
with open("val512_le.bin", "wb") as f:
    for data in data512:
        f.write(data.to_bytes(16*4, byteorder='little'))

with open("val512_le.bin", "rb") as f:
    data = f.read()

val = int.from_bytes(data, byteorder='little')

print(f"0x{val:0{len(data)*2}x}")